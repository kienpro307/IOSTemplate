# Fastfile for iOS Template
# Documentation: https://docs.fastlane.tools/

default_platform(:ios)

platform :ios do
  # Before all lanes
  before_all do
    ensure_git_status_clean unless ENV['SKIP_GIT_CHECK']
    setup_ci if ENV['CI']
  end

  # After all lanes
  after_all do |lane|
    notification(
      title: "Fastlane",
      subtitle: "Lane #{lane} finished",
      message: "Successfully completed #{lane}",
      sound: "default"
    )
  end

  # Error handling
  error do |lane, exception|
    notification(
      title: "Fastlane Error",
      subtitle: "Lane #{lane} failed",
      message: exception.message,
      sound: "default"
    )
  end

  # MARK: - Test Lanes

  desc "Run all tests"
  lane :test do
    scan(
      scheme: ENV['SCHEME'],
      device: ENV['DEVICE'] || "iPhone 15 Pro",
      code_coverage: true,
      output_directory: "./fastlane/test_output",
      output_types: "html,junit",
      clean: true
    )
  end

  desc "Run tests with code coverage"
  lane :test_coverage do
    scan(
      scheme: ENV['SCHEME'],
      device: ENV['DEVICE'] || "iPhone 15 Pro",
      code_coverage: true,
      xcargs: "-enableCodeCoverage YES"
    )

    # Generate coverage report
    slather(
      scheme: ENV['SCHEME'],
      proj: "#{ENV['SCHEME']}.xcodeproj",
      output_directory: "./fastlane/coverage",
      html: true,
      show: true
    )
  end

  # MARK: - Build Lanes

  desc "Build the app"
  lane :build do
    build_app(
      scheme: ENV['SCHEME'],
      configuration: "Debug",
      skip_archive: true,
      skip_codesigning: true,
      clean: true
    )
  end

  desc "Build for release"
  lane :build_release do
    increment_build_number(xcodeproj: "#{ENV['SCHEME']}.xcodeproj")

    build_app(
      scheme: ENV['SCHEME'],
      configuration: "Release",
      export_method: "app-store",
      output_directory: "./build",
      output_name: "#{ENV['SCHEME']}.ipa",
      clean: true,
      include_bitcode: false,
      include_symbols: true
    )
  end

  # MARK: - Beta Deployment

  desc "Deploy a new version to TestFlight"
  lane :beta do
    # Ensure we're on clean state
    ensure_git_branch(branch: 'main')
    git_pull

    # Increment build number
    increment_build_number(xcodeproj: "#{ENV['SCHEME']}.xcodeproj")

    # Setup code signing with Match
    match(type: "appstore", readonly: true) unless ENV['SKIP_MATCH']

    # Run tests
    test unless ENV['SKIP_TESTS']

    # Build app
    build_app(
      scheme: ENV['SCHEME'],
      configuration: "Release",
      export_method: "app-store",
      output_directory: "./build",
      clean: true
    )

    # Upload to TestFlight
    upload_to_testflight(
      skip_waiting_for_build_processing: false,
      distribute_external: true,
      groups: ["External Testers"],
      changelog: generate_changelog,
      notify_external_testers: true
    )

    # Upload dSYMs to Crashlytics
    upload_symbols_to_crashlytics(
      gsp_path: "./GoogleService-Info.plist"
    )

    # Commit build number increment
    commit_version_bump(
      message: "chore: bump build number [skip ci]",
      xcodeproj: "#{ENV['SCHEME']}.xcodeproj"
    )
    push_to_git_remote

    # Slack notification
    slack(
      message: "Successfully uploaded build to TestFlight! ðŸš€",
      success: true,
      default_payloads: [:git_branch, :git_author]
    ) if ENV['SLACK_URL']
  end

  # MARK: - Production Deployment

  desc "Deploy a new version to the App Store"
  lane :release do
    # Ensure we're on clean state
    ensure_git_branch(branch: 'main')
    git_pull

    # Increment version
    version = prompt(text: "Enter version number: ")
    increment_version_number(version_number: version)
    increment_build_number(xcodeproj: "#{ENV['SCHEME']}.xcodeproj")

    # Setup code signing
    match(type: "appstore", readonly: true) unless ENV['SKIP_MATCH']

    # Run tests
    test unless ENV['SKIP_TESTS']

    # Build app
    build_app(
      scheme: ENV['SCHEME'],
      configuration: "Release",
      export_method: "app-store",
      output_directory: "./build",
      clean: true
    )

    # Upload to App Store
    upload_to_app_store(
      submit_for_review: true,
      automatic_release: false,
      force: true,
      skip_metadata: false,
      skip_screenshots: false,
      precheck_include_in_app_purchases: false
    )

    # Upload dSYMs
    upload_symbols_to_crashlytics(
      gsp_path: "./GoogleService-Info.plist"
    )

    # Create Git tag
    add_git_tag(
      tag: "v#{version}",
      message: "Release version #{version}"
    )

    # Commit and push
    commit_version_bump(
      message: "chore: release version #{version} [skip ci]",
      xcodeproj: "#{ENV['SCHEME']}.xcodeproj"
    )
    push_to_git_remote
    push_git_tags

    # Slack notification
    slack(
      message: "Successfully released version #{version} to App Store! ðŸŽ‰",
      success: true,
      default_payloads: [:git_branch, :git_author, :last_git_commit]
    ) if ENV['SLACK_URL']
  end

  # MARK: - Code Signing

  desc "Setup code signing with Match"
  lane :match_development do
    match(
      type: "development",
      readonly: false,
      force_for_new_devices: true
    )
  end

  desc "Setup App Store code signing"
  lane :match_appstore do
    match(
      type: "appstore",
      readonly: false
    )
  end

  desc "Sync all certificates and profiles"
  lane :match_all do
    match(type: "development", readonly: false, force_for_new_devices: true)
    match(type: "appstore", readonly: false)
  end

  desc "Nuke certificates (use with caution!)"
  lane :match_nuke do
    match_nuke(type: "development")
    match_nuke(type: "appstore")
  end

  # MARK: - Utilities

  desc "Take screenshots for App Store"
  lane :screenshots do
    capture_screenshots(
      scheme: "#{ENV['SCHEME']}UITests",
      output_directory: "./fastlane/screenshots",
      clear_previous_screenshots: true,
      devices: [
        "iPhone 15 Pro Max",
        "iPhone 15 Pro",
        "iPhone SE (3rd generation)",
        "iPad Pro (12.9-inch) (6th generation)"
      ]
    )

    # Frame screenshots
    frame_screenshots(
      white: true,
      path: "./fastlane/screenshots"
    )
  end

  desc "Generate changelog from git commits"
  private_lane :generate_changelog do
    changelog = changelog_from_git_commits(
      between: [last_git_tag, "HEAD"],
      pretty: "- %s",
      merge_commit_filtering: "exclude_merges"
    )

    changelog || "Bug fixes and performance improvements"
  end

  desc "Bump version number"
  lane :bump_version do |options|
    version_type = options[:type] || "patch"

    case version_type
    when "major"
      increment_version_number(bump_type: "major")
    when "minor"
      increment_version_number(bump_type: "minor")
    when "patch"
      increment_version_number(bump_type: "patch")
    else
      UI.user_error!("Invalid version type: #{version_type}")
    end

    version = get_version_number
    UI.success("Version bumped to #{version}")
  end

  desc "Setup project for new developer"
  lane :setup do
    # Install dependencies
    sh "bundle install"

    # Setup code signing
    match_development

    # Install SwiftLint
    sh "brew install swiftlint || true"

    UI.success("Setup complete! You can now run the project.")
  end

  desc "Clean build artifacts and derived data"
  lane :clean do
    clean_build_artifacts
    clear_derived_data

    UI.success("Clean complete!")
  end

  desc "Run SwiftLint"
  lane :lint do
    swiftlint(
      mode: :lint,
      config_file: ".swiftlint.yml",
      raise_if_swiftlint_error: true
    )
  end

  desc "Auto-fix SwiftLint issues"
  lane :lint_fix do
    swiftlint(
      mode: :fix,
      config_file: ".swiftlint.yml"
    )
  end

  desc "Validate project before PR"
  lane :validate do
    lint
    test
    build

    UI.success("âœ“ Project validation passed!")
  end

  # MARK: - Notifications

  desc "Send notification to Slack"
  private_lane :notify_slack do |options|
    slack(
      message: options[:message],
      success: options[:success] || true,
      slack_url: ENV['SLACK_URL'],
      default_payloads: [:git_branch, :git_author],
      attachment_properties: {
        fields: [
          {
            title: "Build Number",
            value: get_build_number
          },
          {
            title: "Version",
            value: get_version_number
          }
        ]
      }
    )
  end
end
